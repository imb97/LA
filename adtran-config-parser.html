<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPON Adtran Config Parser</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f8fafc;
            min-height: 10vh; /* Mengurangi min-height karena konten sudah cukup */
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #1e293b;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            color: #64748b;
            font-size: 1.1rem;
        }

        /* Modifikasi gaya untuk drag and drop */
        .upload-card {
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 2px dashed #cbd5e1; /* Mengubah border menjadi dashed */
            margin-bottom: 30px;
            text-align: center;
            transition: border-color 0.3s ease, background 0.3s ease; /* Transisi untuk hover/drag */
        }

        .upload-card.drag-over {
            border-color: #3b82f6; /* Warna border saat drag-over */
            background: #eff6ff; /* Background saat drag-over */
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: #3b82f6;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .file-input-label:hover {
            background: #2563eb;
        }

        .parse-btn {
            display: inline-block;
            padding: 12px 32px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-left: 15px;
            transition: all 0.2s ease;
        }

        .parse-btn:hover:not(:disabled) {
            background: #059669;
        }

        .parse-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .status {
            margin-top: 20px;
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 500;
            display: none;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }
        .status.info { /* Gaya baru untuk pesan processing */
            background: #e0f2fe;
            color: #0c4a6e;
            border: 1px solid #7dd3fc;
        }


        .results-section, .summary-section, .unused-evc-section { /* Tambahkan .unused-evc-section */
            display: none;
        }

        .results-section.show {
            display: block;
        }

        .stats {
            display: grid;
            /* Diubah kembali ke auto-fit untuk responsivitas dengan 7 kartu */
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 8px;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .table-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .summary-section, .unused-evc-section { /* Styling untuk section summary dan unused EVC baru */
            margin-top: 40px;
            margin-bottom: 30px;
        }

        .unused-evc-list {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            padding: 20px;
        }

        .unused-evc-list ul {
            list-style-type: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .unused-evc-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #e2e8f0;
            color: #4a5568;
        }

        .unused-evc-list li:last-child {
            border-bottom: none;
        }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th {
            background: #f8fafc;
            color: #374151;
            padding: 16px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 1px solid #e2e8f0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #f1f5f9;
        }

        tr:hover td {
            background-color: #f8fafc;
        }

        .mode-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mode-trunk {
            background: #fef2f2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }

        .mode-access {
            background: #f0fdf4;
            color: #16a34a;
            border: 1px solid #bbf7d0;
        }

		/* Container untuk tombol export */
		.export-buttons {
			display: flex;
			gap: 10px;
			margin-bottom: 20px;
			flex-wrap: wrap;
		}

        .export-btn {
			display: inline-block;
			padding: 10px 20px;
			color: white;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			font-weight: 500;
			transition: all 0.2s ease;
		}

        .export-btn:hover:not(:disabled) {
            background: #0284c7; /* Warna biru lebih gelap saat hover */
        }

        .export-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

		.export-csv {
			background: #0ea5e9;
		}

		.export-csv:hover:not(:disabled) {
			background: #0284c7;
		}

		.export-excel {
			background: #16a34a;
		}

		.export-excel:hover:not(:disabled) {
			background: #15803d;
		}

        /* Tambahan styling untuk tabel summary */
        #snModemSummaryTable th:nth-child(1),
        #snModemSummaryTable td:nth-child(1) {
            width: 25%; /* OLT column */
        }
        #snModemSummaryTable th:nth-child(2),
        #snModemSummaryTable td:nth-child(2) {
            width: 20%; /* Total SN Modem column */
        }
        #snModemSummaryTable th:nth-child(3),
        #snModemSummaryTable td:nth-child(3) {
            width: 27.5%; /* BW Down */
        }
        #snModemSummaryTable th:nth-child(4),
        #snModemSummaryTable td:nth-child(4) {
            width: 27.5%; /* BW Up */
        }


        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .parse-btn {
                margin-left: 0;
                margin-top: 10px;
            }

            .stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GPON Adtran Config Parser</h1>
        </div>

        <div class="upload-card" id="uploadCard">
            <div class="file-input-wrapper">
                <input type="file" id="configFile" class="file-input" accept=".txt">
                <label for="configFile" class="file-input-label">
                    üìÅ Pilih File Config (.txt)
                </label>
            </div>
            <button id="parseBtn" class="parse-btn" disabled>
                üîÑ Parse Configuration
            </button>
            <div id="status" class="status"></div>
        </div>

        <div id="resultsSection" class="results-section">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalConfigs">0</div>
                    <div class="stat-label">Total Configs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalUniqueOlts">0</div>
                    <div class="stat-label">Total OLTs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalSnModemsOverall">0</div>
                    <div class="stat-label">Total ONTs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalBandwidthDownload">0 Kbps</div>
                    <div class="stat-label">Total BW Down</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalBandwidthUpload">0 Kbps</div>
                    <div class="stat-label">Total BW Up</div>
                </div>
            </div>

            <div class="summary-section" id="snModemSummarySection">
                <h2 style="font-size: 1.5rem; color: #1e293b; margin-bottom: 20px;">ONT Summary per OLT</h2>
                <div class="table-card">
                    <div class="table-container">
                        <table id="snModemSummaryTable">
                            <thead>
                                <tr>
                                    <th>OLT</th>
                                    <th>Total ONTs</th>
                                    <th>Total BW Down</th>
                                    <th>Total BW Up</th>
                                </tr>
                            </thead>
                            <tbody id="snModemSummaryTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="unused-evc-section" id="unusedEvcSection">
                <h2 style="font-size: 1.5rem; color: #1e293b; margin-bottom: 20px;">Unused EVCs</h2>
                <div class="unused-evc-list">
                    <ul id="unusedEvcList">
                        </ul>
                </div>
            </div>
            <div class="export-buttons">
				<button id="exportCsvBtn" class="export-btn export-csv" disabled>
					‚¨áÔ∏è Export ke CSV
				</button>
				<button id="exportExcelBtn" class="export-btn export-excel" disabled>
					üìä Export ke Excel
				</button>
			</div>

            <div class="table-card">
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Service ID</th>
                                <th>Customer Name</th>
                                <th>BW Down (Kbps)</th>
                                <th>BW Up (Kbps)</th>
                                <th>SN Modem</th>
                                <th>ONT</th>
                                <th>OLT</th>
                                <th>Port</th>
                                <th>SVLAN</th>
                                <th>CVLAN</th>
                                <th>Mode</th>
                            </tr>
                        </thead>
                        <tbody id="configTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        let configData = [];
        let selectedFile = null;
        let unusedEvcs = []; // Variabel baru untuk menyimpan EVC yang tidak terpakai

        const configFile = document.getElementById('configFile');
        const parseBtn = document.getElementById('parseBtn');
        const uploadCard = document.getElementById('uploadCard');
		const exportCsvBtn = document.getElementById('exportCsvBtn');
		const exportExcelBtn = document.getElementById('exportExcelBtn');
        const resultsSection = document.getElementById('resultsSection');
        const snModemSummarySection = document.getElementById('snModemSummarySection');
        const totalSnModemsOverallElement = document.getElementById('totalSnModemsOverall');
        const unusedEvcSection = document.getElementById('unusedEvcSection'); // Dapatkan elemen baru

        // --- Fungsi parsing inti ---
        function parseEvcMaps(lines) {
            const evcMaps = [];
            const usedEvcNames = new Set(); // Set untuk menyimpan evcName yang digunakan
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];
                // Mengambil seluruh string dalam kutip ganda
                const evcMapMatch = line.match(/^evc-map\s+"([^"]+)"\s+(\d+)\/(\d+)$/);

                if (evcMapMatch) {
                    const fullEvcName = evcMapMatch[1]; // Contoh: "SERVICEID-CUSTOMERNAME-LAINNYA"
                    let serviceId = fullEvcName;
                    let customerName = '-'; // Default jika tidak ada tanda hubung

                    // Mencari tanda hubung pertama
                    const firstDashIndex = fullEvcName.indexOf('-');

                    if (firstDashIndex !== -1) {
                        serviceId = fullEvcName.substring(0, firstDashIndex); // Bagian sebelum tanda hubung pertama
                        customerName = fullEvcName.substring(firstDashIndex + 1); // Bagian setelah tanda hubung pertama
                    }

                    const evcMap = {
                        serviceId: serviceId,
                        customerName: customerName,
                        x: evcMapMatch[2],
                        y: evcMapMatch[3],
                        mode: 'Access', // default
                        isBridgeGroup: false // Flag baru untuk bridge-group
                    };

                    i++;
                    // Parse isi blok evc-map
                    while (i < lines.length && lines[i] !== '!') {
                        const blockLine = lines[i].trim();

                        if (!blockLine || blockLine.startsWith('*') || blockLine.startsWith('#')) {
                            i++;
                            continue;
                        }

                        // Break jika menemukan block baru
                        if (blockLine.match(/^(evc-map|evc\s|remote-device|shaper|bridge-group)/)) {
                            break;
                        }

                        // Parse connect evc
                        const evcMatch = blockLine.match(/connect\s+evc\s+"([^"]+)"/);
                        if (evcMatch) {
                            evcMap.evcName = evcMatch[1];
                            usedEvcNames.add(evcMatch[1]); // Tambahkan ke set evc yang digunakan
                        }

                        // Parse connect uni gigabit-ethernet
                        const uniGigabitMatch = blockLine.match(/connect\s+uni\s+gigabit-ethernet\s+(\d+)\/(\d+)\/(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon/);
                        if (uniGigabitMatch) {
                            evcMap.ont = uniGigabitMatch[1];
                            evcMap.b = uniGigabitMatch[2];
                            evcMap.port = uniGigabitMatch[3]; // Ambil satu port dari sini
                            evcMap.f = uniGigabitMatch[6];
                            evcMap.isBridgeGroup = false; // Pastikan flag direset
                        }

                        // Parse connect uni bridge-group
                        const uniBridgeGroupMatch = blockLine.match(/connect\s+uni\s+bridge-group\s+(\d+)\/(\d+)\/(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon/);
                        if (uniBridgeGroupMatch) {
                            evcMap.ont = uniBridgeGroupMatch[1];
                            evcMap.b = uniBridgeGroupMatch[2];
                            // evcMap.port dari sini tidak digunakan langsung, akan diisi dari parseBridgeGroups
                            evcMap.f = uniBridgeGroupMatch[6];
                            evcMap.isBridgeGroup = true; // Set flag bridge ke 'true'
                        }

                        // Parse channel
                        const channelMatch = blockLine.match(/connect\s+gpon\s+upstream\s+channel\s+(\d+)/);
                        if (channelMatch) {
                            evcMap.channel = channelMatch[1];
                        }

                        // Parse queue - Pastikan ini menangkap nilai queue jika ada
                        const queueMatch = blockLine.match(/connect\s+qos\s+downstream\s+map-profile\s+(\d+)/);
                        if (queueMatch) {
                            evcMap.queue = queueMatch[1];
                        }

                        // Parse CVLAN
                        const cvlanMatch = blockLine.match(/men-c-tag\s+(\d+)/);
                        if (cvlanMatch) {
                            evcMap.cvlan = cvlanMatch[1];
                        }

                        // Check untuk trunk mode
                        if (blockLine.includes('match ce-vlan-id')) {
                            evcMap.mode = 'Trunk';
                        }

                        i++;
                    }

                    evcMaps.push(evcMap);
                } else {
                    i++;
                }
            }

            return { evcMaps, usedEvcNames }; // Kembalikan evcMaps dan usedEvcNames
        }

        function parseEvcs(lines) {
            const evcs = [];
            const definedEvcNames = new Set(); // Set untuk menyimpan semua evcName yang didefinisikan
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];
                const evcMatch = line.match(/^evc\s+"([^"]+)"$/);

                if (evcMatch) {
                    const evcName = evcMatch[1];
                    definedEvcNames.add(evcName); // Tambahkan ke set evc yang didefinisikan

                    const evc = {
                        evcName: evcName
                    };

                    i++;
                    while (i < lines.length && lines[i] !== '!') {
                        const blockLine = lines[i].trim();

                        if (!blockLine || blockLine.startsWith('*') || blockLine.startsWith('#')) {
                            i++;
                            continue;
                        }

                        // Break jika menemukan block baru
                        if (blockLine.match(/^(evc-map|evc\s|remote-device|shaper|bridge-group)/)) {
                            break;
                        }

                        const sTagMatch = blockLine.match(/s-tag\s+(\d+)/);
                        if (sTagMatch) {
                            evc.sTag = sTagMatch[1];
                        }

                        i++;
                    }

                    evcs.push(evc);
                } else {
                    i++;
                }
            }

            return { evcs, definedEvcNames }; // Kembalikan evcs dan definedEvcNames
        }

        function parseRemoteDevices(lines) {
            const remoteDevices = [];
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];
                const remoteMatch = line.match(/^remote-device\s+ont\s+(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon$/);

                if (remoteMatch) {
                    const device = {
                        ont: remoteMatch[1],
                        x: remoteMatch[2],
                        y: remoteMatch[3],
                        f: remoteMatch[4]
                    };

                    i++;
                    while (i < lines.length && lines[i] !== '!') {
                        const blockLine = lines[i].trim();

                        if (!blockLine || blockLine.startsWith('*') || blockLine.startsWith('#')) {
                            i++;
                            continue;
                        }

                        // Break jika menemukan block baru
                        if (blockLine.match(/^(evc-map|evc\s|remote-device|shaper|bridge-group)/)) {
                            break;
                        }

                        const snMatch = blockLine.match(/serial-number\s+"([^"]+)"/);
                        if (snMatch) {
                            device.serialNumber = snMatch[1];
                        }

                        i++;
                    }

                    remoteDevices.push(device);
                } else {
                    i++;
                }
            }

            return remoteDevices;
        }

		function parseDlShapers(lines) {
			const shapers = [];
			let i = 0;

			while (i < lines.length) {
				const line = lines[i];

				// Cari semua kemungkinan format DL shaper
				const dlMatch = line.match(/^shaper\s+"([^"]*DL[^"]*)"/) ||
							   line.match(/^shaper\s+"([^"]*dl[^"]*)"/) ||
							   line.match(/^shaper\s+"([^"]*down[^"]*)"/) ||
							   line.match(/^shaper\s+"([^"]*DOWN[^"]*)"/) ||
							   line.match(/^shaper\s+"([^"]*Download[^"]*)"/) ||
							   line.match(/^shaper\s+"([^"]*download[^"]*)"/) ||
							   // Format dengan koordinat di akhir
							   line.match(/^shaper\s+"([^"]+)"\s+\d+\/\d+$/);

				if (dlMatch) {
					const shaper = {
						name: dlMatch[1],
						type: 'DL'
					};

					// Ekstrak koordinat dari header jika ada
					const coordMatch = line.match(/(\d+)\/(\d+)$/);
					if (coordMatch) {
						shaper.x = coordMatch[1];
						shaper.y = coordMatch[2];
					}

					i++;
					while (i < lines.length && lines[i] !== '!') {
						const blockLine = lines[i].trim();

						if (!blockLine || blockLine.startsWith('*') || blockLine.startsWith('#')) {
							i++;
							continue;
						}

						// Break jika menemukan block baru
						if (blockLine.match(/^(evc-map|evc\s|remote-device|shaper|bridge-group)/)) {
							break;
						}

						// Parse "per remote-device" atau "per interface"
						const deviceMatch = blockLine.match(/per\s+(?:remote-device|interface)\s+.*?(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon/) ||
										  blockLine.match(/(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon/);
						if (deviceMatch) {
							shaper.ont = deviceMatch[1];
							shaper.x = deviceMatch[2];
							shaper.y = deviceMatch[3];
							shaper.f = deviceMatch[4];

							// Cari queue di line yang sama - PENTING untuk matching
							const queueMatch = blockLine.match(/queue\s+(\d+)/);
							if (queueMatch) {
								shaper.queue = queueMatch[1];
							}
						}

						// Parse rate dari berbagai format
						if (!shaper.rate) {
							// Cari rate pattern
							const patterns = [
								/\brate\s+(\d+)/,           // rate 100000
								/\bcir\s+(\d+)/,            // cir 100000
								/\bpir\s+(\d+)/,            // pir 100000
								/(\d+)\s*kbps/i,            // 100000 kbps
								/(\d+)\s*mbps/i,            // 100 mbps
								/committed.*?(\d+)/i,       // committed rate 100000
								/peak.*?(\d+)/i,            // peak rate 100000
								/bandwidth\s+(\d+)/i        // bandwidth 100000
							];

							for (const pattern of patterns) {
								const match = blockLine.match(pattern);
								if (match) {
									let rate = parseInt(match[1]);

									// Konversi mbps ke kbps jika perlu
									if (blockLine.toLowerCase().includes('mbps')) {
										rate = rate * 1000;
									}

									// Hanya ambil jika rate masuk akal (> 0)
									if (rate > 0) {
										shaper.rate = rate.toString();
										break;
									}
								}
							}

							// Fallback: cari angka standalone yang besar
							if (!shaper.rate && shaper.ont && blockLine.match(/^\d+$/)) {
								const num = parseInt(blockLine);
								if (num > 1000) {
									shaper.rate = num.toString();
								}
							}
						}

						i++;
					}

					// Tambahkan jika punya data minimal - queue sekarang opsional
					if (shaper.ont && shaper.rate && parseInt(shaper.rate) > 0) {
						shapers.push(shaper);
					}
				} else {
					i++;
				}
			}

			return shapers;
		}

        function parseUlShapers(lines) {
            const shapers = [];
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];
                const ulMatch = line.match(/^shaper\s+"UL-[^"]*"\s+(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon$/);

                if (ulMatch) {
                    const shaper = {
                        ont: ulMatch[1],
                        x: ulMatch[2],
                        y: ulMatch[3],
                        f: ulMatch[4],
                        type: 'UL'
                    };

                    i++;
                    while (i < lines.length && lines[i] !== '!') {
                        const blockLine = lines[i].trim();

                        if (!blockLine || blockLine.startsWith('*') || blockLine.startsWith('#')) {
                            i++;
                            continue;
                        }

                        // Break jika menemukan block baru
                        if (blockLine.match(/^(evc-map|evc\s|remote-device|shaper|bridge-group)/)) {
                            break;
                        }

                        // Parse channel - lebih fleksibel dengan berbagai format
                        const channelMatch = blockLine.match(/(?:per\s+interface\s+gpon\s+[^@]+@[^@]+\.gpon\s+channel\s+(\d+)|channel\s+(\d+))/);
                        if (channelMatch) {
                            shaper.channel = channelMatch[1] || channelMatch[2];
                        }

                        // Parse rate dengan berbagai format yang mungkin
                        const rateMatch = blockLine.match(/(?:^|\s)rate\s+(\d+)(?:\s|$)/);
                        if (rateMatch) {
                            shaper.rate = rateMatch[1];
                        }

                        // Alternatif parsing jika format berbeda
                        if (!shaper.rate || shaper.rate === '0') {
                            const altRateMatch = blockLine.match(/(\d+)\s*kbps|(\d+)\s*mbps|(\d+)\s*bps/i);
                            if (altRateMatch) {
                                if (altRateMatch[1]) shaper.rate = altRateMatch[1]; // kbps
                                else if (altRateMatch[2]) shaper.rate = (parseInt(altRateMatch[2]) * 1000).toString(); // mbps to kbps
                                else if (altRateMatch[3]) shaper.rate = Math.floor(parseInt(altRateMatch[3]) / 1000).toString(); // bps to kbps
                            }
                        }

                        // Coba parsing rate di posisi lain dalam line
                        if (!shaper.rate || shaper.rate === '0') {
                            const generalRateMatch = blockLine.match(/(\d+)/);
                            if (generalRateMatch && !blockLine.includes('channel') && !blockLine.includes('queue')) {
                                shaper.rate = generalRateMatch[1];
                            }
                        }

                        i++;
                    }

                    // Hanya tambahkan jika memiliki data penting dan rate > 0
                    if (shaper.ont && shaper.rate && shaper.rate !== '0') {
                        shapers.push(shaper);
                    }
                } else {
                    i++;
                }
            }

            return shapers;
        }

        function parseBridgeGroups(lines) {
            const bridgeGroups = [];
            let i = 0;

            while (i < lines.length) {
                const line = lines[i].trim();
                const bgMatch = line.match(/^bridge-group\s+(\d+)\/(\d+)\/(\d+)@(\d+)\/(\d+)\/(\d+)\.gpon$/);

                if (bgMatch) {
                    const bridgeGroup = {
                        ont: bgMatch[1],
                        b: bgMatch[2],
                        x: bgMatch[4],
                        y: bgMatch[5],
                        f: bgMatch[6],
                        ports: [] // Array untuk menyimpan semua port yang ditambahkan
                    };

                    i++;
                    while (i < lines.length && lines[i].trim() !== '!') {
                        const blockLine = lines[i].trim();

                        if (!blockLine || blockLine.startsWith('*') || blockLine.startsWith('#')) {
                            i++;
                            continue;
                        }

                        // Break jika menemukan block baru
                        if (blockLine.match(/^(evc-map|evc\s|remote-device|shaper|bridge-group)/)) {
                            break;
                        }

                        const addInterfaceMatch = blockLine.match(/add\s+interface\s+gigabit-ethernet\s+\d+\/\d+\/(\d+)@\d+\/\d+\/\d+\.gpon/);
                        if (addInterfaceMatch) {
                            const portNum = addInterfaceMatch[1];
                            if (!bridgeGroup.ports.includes(portNum)) { // Hindari duplikasi
                                bridgeGroup.ports.push(portNum);
                            }
                        }
                        i++;
                    }
                    // Urutkan port secara numerik untuk output yang konsisten
                    bridgeGroup.ports.sort((a, b) => parseInt(a) - parseInt(b));
                    bridgeGroups.push(bridgeGroup);
                } else {
                    i++;
                }
            }
            return bridgeGroups;
        }

        // Fungsi helper untuk memformat bandwidth secara dinamis (Kbps, Mbps, Gbps)
        function formatBandwidth(kbps) {
            const KB_PER_MB = 1024;
            const KB_PER_GB = 1024 * 1024; // 1024^2

            if (typeof kbps !== 'number' || isNaN(kbps)) {
                return '-'; // Handle case where kbps is not a valid number
            }

            if (kbps >= KB_PER_GB) { // Jika lebih dari atau sama dengan 1,048,576 Kbps (1 Gbps)
                return (kbps / KB_PER_GB).toFixed(2) + ' Gbps';
            } else if (kbps >= KB_PER_MB) { // Jika lebih dari atau sama dengan 1,024 Kbps (1 Mbps)
                return (kbps / KB_PER_MB).toFixed(2) + ' Mbps';
            } else { // Tetap Kbps
                return kbps.toLocaleString() + ' Kbps';
            }
        }

        // Fungsi parsing utama
        function parseConfig(configText) {
            const results = [];
            const lines = configText.split('\n').map(line => line.trim());

            // Parse semua blok konfigurasi
            const { evcMaps, usedEvcNames } = parseEvcMaps(lines); // Ambil juga usedEvcNames
            const { evcs, definedEvcNames } = parseEvcs(lines);     // Ambil juga definedEvcNames
            const remoteDevices = parseRemoteDevices(lines);
            const dlShapers = parseDlShapers(lines);
            const ulShapers = parseUlShapers(lines);
            const bridgeGroups = parseBridgeGroups(lines);

            // Gabungkan data berdasarkan relasi
            evcMaps.forEach(evcMap => {
                const result = { ...evcMap };

                // Jika evcMap merujuk ke bridge-group, ambil port dari definisi bridge-group
                if (evcMap.isBridgeGroup && evcMap.ont && evcMap.x && evcMap.y && evcMap.f) {
                    const matchingBridgeGroup = bridgeGroups.find(bg =>
                        bg.ont === evcMap.ont &&
                        bg.x === evcMap.x &&
                        bg.y === evcMap.y &&
                        bg.f === evcMap.f
                    );
                    if (matchingBridgeGroup && matchingBridgeGroup.ports.length > 0) {
                        result.port = matchingBridgeGroup.ports.join(','); // Gabungkan port dengan koma
                    } else {
                        // Jika bridge group ditemukan tapi tidak ada add interface, atau tidak ada bridge group sama sekali
                        result.port = 'Bridge Group'; // Tampilkan sebagai Bridge Group
                    }
                } else if (evcMap.isBridgeGroup && !result.port) {
                     // Fallback jika tidak bisa menemukan bridge group yang cocok sama sekali
                     result.port = 'Bridge Group';
                }

                // Cari EVC yang sesuai
                const evc = evcs.find(e => e.evcName === evcMap.evcName);
                if (evc) {
                    result.svlan = evc.sTag;
                }

                // Cari Remote Device yang sesuai
                const remoteDevice = remoteDevices.find(rd =>
                    rd.ont === evcMap.ont &&
                    rd.x === evcMap.x &&
                    rd.y === evcMap.y &&
                    rd.f === evcMap.f
                );
                if (remoteDevice) {
                    result.snModem = remoteDevice.serialNumber;
                }

                // --- PERBAIKAN LOGIKA PENCARIAN DL SHAPER ---
                let dlShaper = null;

                // Filter semua shaper yang cocok lokasi
                const locationMatchingShapers = dlShapers.filter(ds => {
                    return ds.ont === evcMap.ont &&
                           ds.x === evcMap.x &&
                           ds.y === evcMap.y &&
                           ds.f === evcMap.f;
                });

                if (locationMatchingShapers.length > 0) {
                    // 1. Prioritaskan shaper dengan queue yang sama persis jika evcMap memiliki queue
                    if (evcMap.queue) {
                        dlShaper = locationMatchingShapers.find(ds => ds.queue === evcMap.queue);
                    }

                    // 2. Jika belum ditemukan (misal: evcMap.queue undefined/tidak cocok),
                    //    coba cari shaper yang namanya mengandung serviceId dari evcMap.
                    //    Ini penting karena debug menunjukkan evcMap.queue sering undefined,
                    //    tetapi nama shaper dan serviceId terkait.
                    if (!dlShaper && evcMap.serviceId) {
                        dlShaper = locationMatchingShapers.find(ds => ds.name && ds.name.includes(evcMap.serviceId));
                    }

                    // 3. Fallback: Jika masih belum ditemukan, coba ambil shaper dengan queue "1" (sebagai default umum)
                    if (!dlShaper) {
                        dlShaper = locationMatchingShapers.find(ds => ds.queue === '1');
                    }

                    // 4. Fallback terakhir: Ambil shaper pertama yang cocok berdasarkan lokasi
                    if (!dlShaper) {
                         dlShaper = locationMatchingShapers[0];
                    }
                }

                if (dlShaper) {
                    result.bandwidthDownload = dlShaper.rate;
                }
                // --- AKHIR PERBAIKAN LOGIKA PENCARIAN DL SHAPER ---

                // Cari UL Shaper - lebih fleksibel dalam matching
                const ulShaper = ulShapers.find(us => {
                    const ontMatch = us.ont === evcMap.ont;
                    const locationMatch = us.x === evcMap.x && us.y === evcMap.y && us.f === evcMap.f;
                    // Channel match: us.channel harus cocok dengan evcMap.channel,
                    // atau salah satu dari mereka tidak memiliki channel yang ditentukan.
                    // Ini mengakomodasi kasus di mana channel tidak selalu ada di evcMap atau UL shaper.
                    const channelMatch = !evcMap.channel || !us.channel || us.channel === evcMap.channel;

                    return ontMatch && locationMatch && channelMatch;
                });
                if (ulShaper) {
                    result.bandwidthUpload = ulShaper.rate;
                }

                results.push(result);
            });

            return { results, definedEvcNames, usedEvcNames }; // Kembalikan ketiga nilai
        }

        /**
         * Mengidentifikasi EVC yang didefinisikan tetapi tidak digunakan.
         * @param {Set<string>} definedNames - Set nama EVC yang didefinisikan dalam blok 'evc'.
         * @param {Set<string>} usedNames - Set nama EVC yang direferensikan dalam blok 'evc-map'.
         * @returns {string[]} Array string nama EVC yang tidak terpakai.
         */
        function findUnusedEvcs(definedNames, usedNames) {
            const unused = [];
            definedNames.forEach(name => {
                if (!usedNames.has(name)) {
                    unused.push(name);
                }
            });
            return unused.sort(); // Urutkan untuk konsistensi
        }


        // Fungsi untuk memproses file yang dipilih/di-drop
        function handleFileSelection(file) {
            if (file && file.type === 'text/plain') {
                selectedFile = file;
                parseBtn.disabled = false;
                showStatus('File berhasil dipilih: ' + file.name, 'success');
            } else {
                selectedFile = null;
                parseBtn.disabled = true;
                showStatus('Silakan pilih file .txt yang valid', 'error');
            }
			exportCsvBtn.disabled = true;
			exportExcelBtn.disabled = true;
            resultsSection.classList.remove('show'); // Hide results section on new file selection
            snModemSummarySection.style.display = 'none';
            unusedEvcSection.style.display = 'none'; // Sembunyikan bagian EVC tidak terpakai
        }

        // --- Fungsi untuk memulai proses parsing ---
        function startParsing(fileToParse) {
            if (!fileToParse) {
                showStatus('Silakan pilih file terlebih dahulu', 'error');
                return;
            }

            showStatus('Sedang memproses data, mohon tunggu...', 'info');
            parseBtn.disabled = true;
			exportCsvBtn.disabled = true;
			exportExcelBtn.disabled = true;
            resultsSection.classList.remove('show'); // Hide previous results
            snModemSummarySection.style.display = 'none';
            unusedEvcSection.style.display = 'none'; // Sembunyikan EVC tidak terpakai
            configData = [];
            unusedEvcs = []; // Reset unusedEvcs

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const configText = e.target.result;
                    const { results, definedEvcNames, usedEvcNames } = parseConfig(configText);
                    configData = results; // Simpan hasil parsing utama

                    // Hitung summary SN Modem unik per OLT
                    const snModemSummary = summarizeSnModemPerOlt(configData);

                    // Temukan EVC yang tidak terpakai
                    unusedEvcs = findUnusedEvcs(definedEvcNames, usedEvcNames);

                    // Tampilkan semua hasil
                    displayResults(configData, snModemSummary, unusedEvcs);

                    showStatus(`Berhasil mem-parse ${configData.length} konfigurasi dari file ${fileToParse.name}`, 'success');
					exportCsvBtn.disabled = false;
					exportExcelBtn.disabled = false;
                } catch (error) {
                    showStatus('Error parsing file: ' + error.message, 'error');
                    console.error('Parsing error:', error); // Tetap pertahankan console.error
					exportCsvBtn.disabled = true;
					exportExcelBtn.disabled = true;
                } finally {
                    parseBtn.disabled = false;
                }
            };
            reader.onerror = function() {
                showStatus('Gagal membaca file.', 'error');
                parseBtn.disabled = false;
				exportCsvBtn.disabled = true;
				exportExcelBtn.disabled = true;
            };
            reader.readAsText(fileToParse);
        }

        // --- Event Listener untuk input file standar ---
        configFile.addEventListener('change', function(e) {
            handleFileSelection(e.target.files[0]);
        });

        // --- Event Listener untuk Drag and Drop ---
        uploadCard.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadCard.classList.add('drag-over');
        });

        uploadCard.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadCard.classList.remove('drag-over');
        });

        uploadCard.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadCard.classList.remove('drag-over');

            const droppedFiles = e.dataTransfer.files;
            if (droppedFiles.length > 0) {
                handleFileSelection(droppedFiles[0]);
            }
        });

        // --- Event Listener untuk tombol Parse ---
        parseBtn.addEventListener('click', function() {
            startParsing(selectedFile);
        });

		// Event Listener untuk tombol Export CSV
		exportCsvBtn.addEventListener('click', function() {
			if (configData.length > 0) {
				exportToCsv(configData, 'GPON_Adtran_Config_Data.csv');
			} else {
				showStatus('Tidak ada data untuk diekspor.', 'error');
			}
		});

		// Event Listener untuk tombol Export Excel
		exportExcelBtn.addEventListener('click', function() {
			if (configData.length > 0) {
				exportToExcel(configData, 'GPON_Adtran_Config_Data.xlsx');
			} else {
				showStatus('Tidak ada data untuk diekspor.', 'error');
			}
		});

        // MODIFIED: Fungsi untuk menampilkan hasil dan statistik, termasuk EVC yang tidak terpakai dan unique SNs
        function displayResults(data, snModemSummary, unusedEvcs) {
            const tbody = document.getElementById('configTableBody');

            tbody.innerHTML = '';

            let totalDownload = 0;
            let totalUpload = 0;
            const uniqueSnModemsOverall = new Set(); // Set baru untuk SN Modem unik keseluruhan

            data.forEach(config => {
                const row = tbody.insertRow();

                const modeClass = config.mode === 'Trunk' ? 'mode-trunk' : 'mode-access';

                if (config.snModem && config.snModem !== '-') {
                    uniqueSnModemsOverall.add(config.snModem); // Tambahkan ke Set unik
                }

                // Tambahkan ke total bandwidth
                totalDownload += parseInt(config.bandwidthDownload || 0);
                totalUpload += parseInt(config.bandwidthUpload || 0);


                let cvlanDisplay = config.cvlan;
                let svlanDisplay = config.svlan;

                // Logika: Jika CVLAN tidak ada, tampilkan SVLAN di kolom CVLAN
                if (!cvlanDisplay) {
                    cvlanDisplay = svlanDisplay;
                    svlanDisplay = '-';
                }

                // Urutan kolom yang baru
                row.innerHTML = `
                    <td>${config.serviceId || '-'}</td>
                    <td>${config.customerName || '-'}</td>
                    <td>${config.bandwidthDownload || '-'}</td>
                    <td>${config.bandwidthUpload || '-'}</td>
                    <td>${config.snModem || '-'}</td>
                    <td>${config.ont || '-'}</td>
                    <td>${config.x || '-'}/${config.y || '-'}/${config.f || '-'}</td>
                    <td>${config.port || '-'}</td> <td>${svlanDisplay || '-'}</td>
                    <td>${cvlanDisplay || '-'}</td>
                    <td><span class="mode-badge ${modeClass}">${config.mode}</span></td>
                `;
            });

            // Update statistik
            document.getElementById('totalConfigs').textContent = data.length;

            document.getElementById('totalUniqueOlts').textContent = snModemSummary.length;

            // Gunakan ukuran Set untuk total SN Modem unik keseluruhan
            document.getElementById('totalSnModemsOverall').textContent = uniqueSnModemsOverall.size;

            document.getElementById('totalBandwidthDownload').textContent = formatBandwidth(totalDownload);
            document.getElementById('totalBandwidthUpload').textContent = formatBandwidth(totalUpload);

            resultsSection.classList.add('show');

            // Tampilkan tabel summary SN Modem per OLT
            displaySnModemSummary(snModemSummary);

            // Tampilkan EVC yang tidak terpakai
            displayUnusedEvcs(unusedEvcs);
        }

        // Fungsi untuk membuat summary jumlah SN Modem unik dan bandwidth per OLT
        function summarizeSnModemPerOlt(data) {
            const oltSummaryMap = new Map();

            data.forEach(config => {
                const oltKey = `${config.x || '-'}/${config.y || '-'}/${config.f || '-'}`;
                const snModem = config.snModem;
                const bwDown = parseInt(config.bandwidthDownload || 0);
                const bwUp = parseInt(config.bandwidthUpload || 0);

                if (oltKey !== '-/-/-') {
                    if (!oltSummaryMap.has(oltKey)) {
                        oltSummaryMap.set(oltKey, {
                            uniqueSnModems: new Set(), // Gunakan Set untuk melacak SN Modem unik per OLT
                            totalBwDown: 0,
                            totalBwUp: 0
                        });
                    }

                    const currentOlt = oltSummaryMap.get(oltKey);
                    if (snModem && snModem !== '-') {
                        currentOlt.uniqueSnModems.add(snModem); // Tambahkan SN Modem ke Set
                    }
                    currentOlt.totalBwDown += bwDown;
                    currentOlt.totalBwUp += bwUp;
                }
            });

            const summaryArray = Array.from(oltSummaryMap, ([olt, summary]) => ({
                olt: olt,
                totalSnModemCount: summary.uniqueSnModems.size, // Ambil ukuran Set untuk jumlah unik
                totalBwDown: summary.totalBwDown,
                totalBwUp: summary.totalBwUp
            }));

            summaryArray.sort((a, b) => a.olt.localeCompare(b.olt));

            return summaryArray;
        }

        // Fungsi untuk menampilkan summary SN Modem per OLT
        function displaySnModemSummary(summaryData) {
            const tbody = document.getElementById('snModemSummaryTableBody');

            tbody.innerHTML = '';

            if (summaryData.length > 0) {
                summaryData.forEach(item => {
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${item.olt}</td>
                        <td>${item.totalSnModemCount}</td>
                        <td>${formatBandwidth(item.totalBwDown)}</td>
                        <td>${formatBandwidth(item.totalBwUp)}</td>
                    `;
                });
                snModemSummarySection.style.display = 'block';
            } else {
                snModemSummarySection.style.display = 'none';
            }
        }

        // NEW FUNCTION: Untuk menampilkan daftar EVC yang tidak terpakai
        function displayUnusedEvcs(unusedEvcs) {
            const unusedEvcList = document.getElementById('unusedEvcList');
            unusedEvcList.innerHTML = ''; // Bersihkan daftar sebelumnya

            if (unusedEvcs.length > 0) {
                unusedEvcs.forEach(evcName => {
                    const listItem = document.createElement('li');
                    listItem.textContent = evcName;
                    unusedEvcList.appendChild(listItem);
                });
                unusedEvcSection.style.display = 'block'; // Tampilkan bagian
            } else {
                unusedEvcSection.style.display = 'none'; // Sembunyikan jika tidak ada
            }
        }


        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            if (type !== 'info') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }
        }

        // --- Fungsi baru untuk export ke CSV ---
        function escapeCsvValue(value) {
            if (value === null || value === undefined) {
                return '';
            }
            // Ubah semua menjadi string
            let stringValue = String(value);
            // Jika mengandung koma, kutip ganda, atau newline, sertakan dalam tanda kutip ganda
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                // Escaping kutip ganda dengan menggandakannya
                stringValue = stringValue.replace(/"/g, '""');
                return `"${stringValue}"`;
            }
            return stringValue;
            }

        function exportToCsv(data, filename) {
            // Urutan header yang baru
            const headers = [
                "Service ID", "Customer Name", "BW Down (Kbps)", "BW Up (Kbps)", "SN Modem",
                "ONT", "OLT", "Port", "SVLAN", "CVLAN", "Mode"
            ];

            let csv = headers.map(escapeCsvValue).join(',') + '\n'; // Baris header

            data.forEach(config => {
                // Terapkan logika CVLAN/SVLAN yang sama seperti di displayResults untuk konsistensi
                let cvlanExport = config.cvlan;
                let svlanExport = config.svlan;
                if (!cvlanExport) {
                    cvlanExport = svlanExport;
                    svlanExport = '-';
                }

                // Urutan kolom yang baru
                const row = [
                    config.serviceId,
                    config.customerName,
                    config.bandwidthDownload,
                    config.bandwidthUpload,
                    config.snModem,
                    config.ont,
                    `${config.x || '-'}/${config.y || '-'}/${config.f || '-'}`, // OLT gabungan
                    config.port, // Ini sekarang bisa berupa "1,2" atau "Bridge Group"
                    svlanExport, // Gunakan nilai yang sudah diproses
                    cvlanExport, // Gunakan nilai yang sudah diproses
                    config.mode
                ];
                csv += row.map(value => escapeCsvValue(value || '-')).join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Cek dukungan browser
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert('Browser Anda tidak mendukung pengunduhan file secara langsung. Silakan salin teks dari debug info.');
            }
        }
		function exportToExcel(data, filename) {
			// Header yang sama dengan CSV
			const headers = [
				"Service ID", "Customer Name", "BW Down (Kbps)", "BW Up (Kbps)", "SN Modem",
				"ONT", "OLT", "Port", "SVLAN", "CVLAN", "Mode"
			];

			// Siapkan data untuk worksheet
			const worksheetData = [headers];

			data.forEach(config => {
				// Terapkan logika CVLAN/SVLAN yang sama
				let cvlanExport = config.cvlan;
				let svlanExport = config.svlan;
				if (!cvlanExport) {
					cvlanExport = svlanExport;
					svlanExport = '-';
				}

				const row = [
					config.serviceId || '-',
					config.customerName || '-',
					config.bandwidthDownload || '-',
					config.bandwidthUpload || '-',
					config.snModem || '-',
					config.ont || '-',
					`${config.x || '-'}/${config.y || '-'}/${config.f || '-'}`,
					config.port || '-',
					svlanExport || '-',
					cvlanExport || '-',
					config.mode || '-'
				];
				worksheetData.push(row);
			});

			// Buat workbook dan worksheet
			const wb = XLSX.utils.book_new();
			const ws = XLSX.utils.aoa_to_sheet(worksheetData);

			// Set lebar kolom
			const colWidths = [
				{wch: 15}, // Service ID
				{wch: 25}, // Customer Name
				{wch: 15}, // BW Down
				{wch: 15}, // BW Up
				{wch: 20}, // SN Modem
				{wch: 8},  // ONT
				{wch: 15}, // OLT
				{wch: 12}, // Port
				{wch: 10}, // SVLAN
				{wch: 10}, // CVLAN
				{wch: 8}   // Mode
			];
			ws['!cols'] = colWidths;

			// Tambahkan worksheet ke workbook
			XLSX.utils.book_append_sheet(wb, ws, "EVC Config Data");

			// Download file
			XLSX.writeFile(wb, filename);
		}
    </script>
</body>
</html>